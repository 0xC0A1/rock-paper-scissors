/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import {
  Account,
  Context,
  Option,
  OptionOrNullable,
  Pda,
  PublicKey,
  RpcAccount,
  RpcGetAccountOptions,
  RpcGetAccountsOptions,
  assertAccountExists,
  deserializeAccount,
  gpaBuilder,
  publicKey as toPublicKey,
} from '@metaplex-foundation/umi';
import {
  Serializer,
  bytes,
  i64,
  option,
  publicKey as publicKeySerializer,
  string,
  struct,
  u64,
  u8,
} from '@metaplex-foundation/umi/serializers';
import {
  Choice,
  ChoiceArgs,
  GameState,
  GameStateArgs,
  getChoiceSerializer,
  getGameStateSerializer,
} from '../types';

export type Game = Account<GameAccountData>;

export type GameAccountData = {
  bump: number;
  gameId: string;
  mint: PublicKey;
  tokenProgram: PublicKey;
  amountToMatch: bigint;
  firstPlayer: PublicKey;
  firstPlayerHash: Uint8Array;
  firstPlayerEscrow: PublicKey;
  firstPlayerChoice: Option<Choice>;
  firstPlayerRevealedAt: Option<bigint>;
  secondPlayer: Option<PublicKey>;
  secondPlayerHash: Option<Uint8Array>;
  secondPlayerEscrow: Option<PublicKey>;
  secondPlayerChoice: Option<Choice>;
  secondPlayerRevealedAt: Option<bigint>;
  amountWon: Option<bigint>;
  drawnAt: Option<bigint>;
  state: GameState;
  createdAt: bigint;
};

export type GameAccountDataArgs = {
  bump: number;
  gameId: string;
  mint: PublicKey;
  tokenProgram: PublicKey;
  amountToMatch: number | bigint;
  firstPlayer: PublicKey;
  firstPlayerHash: Uint8Array;
  firstPlayerEscrow: PublicKey;
  firstPlayerChoice: OptionOrNullable<ChoiceArgs>;
  firstPlayerRevealedAt: OptionOrNullable<number | bigint>;
  secondPlayer: OptionOrNullable<PublicKey>;
  secondPlayerHash: OptionOrNullable<Uint8Array>;
  secondPlayerEscrow: OptionOrNullable<PublicKey>;
  secondPlayerChoice: OptionOrNullable<ChoiceArgs>;
  secondPlayerRevealedAt: OptionOrNullable<number | bigint>;
  amountWon: OptionOrNullable<number | bigint>;
  drawnAt: OptionOrNullable<number | bigint>;
  state: GameStateArgs;
  createdAt: number | bigint;
};

export function getGameAccountDataSerializer(): Serializer<
  GameAccountDataArgs,
  GameAccountData
> {
  return struct<GameAccountData>(
    [
      ['bump', u8()],
      ['gameId', string()],
      ['mint', publicKeySerializer()],
      ['tokenProgram', publicKeySerializer()],
      ['amountToMatch', u64()],
      ['firstPlayer', publicKeySerializer()],
      ['firstPlayerHash', bytes({ size: 32 })],
      ['firstPlayerEscrow', publicKeySerializer()],
      ['firstPlayerChoice', option(getChoiceSerializer())],
      ['firstPlayerRevealedAt', option(i64())],
      ['secondPlayer', option(publicKeySerializer())],
      ['secondPlayerHash', option(bytes({ size: 32 }))],
      ['secondPlayerEscrow', option(publicKeySerializer())],
      ['secondPlayerChoice', option(getChoiceSerializer())],
      ['secondPlayerRevealedAt', option(i64())],
      ['amountWon', option(u64())],
      ['drawnAt', option(i64())],
      ['state', getGameStateSerializer()],
      ['createdAt', i64()],
    ],
    { description: 'GameAccountData' }
  ) as Serializer<GameAccountDataArgs, GameAccountData>;
}

export function deserializeGame(rawAccount: RpcAccount): Game {
  return deserializeAccount(rawAccount, getGameAccountDataSerializer());
}

export async function fetchGame(
  context: Pick<Context, 'rpc'>,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions
): Promise<Game> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options
  );
  assertAccountExists(maybeAccount, 'Game');
  return deserializeGame(maybeAccount);
}

export async function safeFetchGame(
  context: Pick<Context, 'rpc'>,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions
): Promise<Game | null> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options
  );
  return maybeAccount.exists ? deserializeGame(maybeAccount) : null;
}

export async function fetchAllGame(
  context: Pick<Context, 'rpc'>,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions
): Promise<Game[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options
  );
  return maybeAccounts.map((maybeAccount) => {
    assertAccountExists(maybeAccount, 'Game');
    return deserializeGame(maybeAccount);
  });
}

export async function safeFetchAllGame(
  context: Pick<Context, 'rpc'>,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions
): Promise<Game[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options
  );
  return maybeAccounts
    .filter((maybeAccount) => maybeAccount.exists)
    .map((maybeAccount) => deserializeGame(maybeAccount as RpcAccount));
}

export function getGameGpaBuilder(context: Pick<Context, 'rpc' | 'programs'>) {
  const programId = context.programs.getPublicKey(
    'rockPaperScissors',
    'rock7uz5eZdz8fb1ZEfZ1aR428ncvkYBrgebwyzaqBG'
  );
  return gpaBuilder(context, programId)
    .registerFields<{
      bump: number;
      gameId: string;
      mint: PublicKey;
      tokenProgram: PublicKey;
      amountToMatch: number | bigint;
      firstPlayer: PublicKey;
      firstPlayerHash: Uint8Array;
      firstPlayerEscrow: PublicKey;
      firstPlayerChoice: OptionOrNullable<ChoiceArgs>;
      firstPlayerRevealedAt: OptionOrNullable<number | bigint>;
      secondPlayer: OptionOrNullable<PublicKey>;
      secondPlayerHash: OptionOrNullable<Uint8Array>;
      secondPlayerEscrow: OptionOrNullable<PublicKey>;
      secondPlayerChoice: OptionOrNullable<ChoiceArgs>;
      secondPlayerRevealedAt: OptionOrNullable<number | bigint>;
      amountWon: OptionOrNullable<number | bigint>;
      drawnAt: OptionOrNullable<number | bigint>;
      state: GameStateArgs;
      createdAt: number | bigint;
    }>({
      bump: [0, u8()],
      gameId: [1, string()],
      mint: [null, publicKeySerializer()],
      tokenProgram: [null, publicKeySerializer()],
      amountToMatch: [null, u64()],
      firstPlayer: [null, publicKeySerializer()],
      firstPlayerHash: [null, bytes({ size: 32 })],
      firstPlayerEscrow: [null, publicKeySerializer()],
      firstPlayerChoice: [null, option(getChoiceSerializer())],
      firstPlayerRevealedAt: [null, option(i64())],
      secondPlayer: [null, option(publicKeySerializer())],
      secondPlayerHash: [null, option(bytes({ size: 32 }))],
      secondPlayerEscrow: [null, option(publicKeySerializer())],
      secondPlayerChoice: [null, option(getChoiceSerializer())],
      secondPlayerRevealedAt: [null, option(i64())],
      amountWon: [null, option(u64())],
      drawnAt: [null, option(i64())],
      state: [null, getGameStateSerializer()],
      createdAt: [null, i64()],
    })
    .deserializeUsing<Game>((account) => deserializeGame(account));
}
